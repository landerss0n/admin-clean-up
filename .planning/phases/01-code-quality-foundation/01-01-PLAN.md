---
phase: 01-code-quality-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - admin-clean-up.php
  - includes/class-admin-page.php
  - uninstall.php
autonomous: true

must_haves:
  truths:
    - "Adding a new option key to any nested settings array applies the default correctly on next page load"
    - "The string 'wp_clean_up_options' appears nowhere in the codebase except the constant definition"
    - "A fresh activation on a clean site produces an options array matching the current full structure (all 45 keys present across 9 tabs)"
  artifacts:
    - path: "admin-clean-up.php"
      provides: "OPTION_KEY constant, parse_args_recursive() method, updated get_options(), updated activation hook"
      contains: "const OPTION_KEY"
    - path: "includes/class-admin-page.php"
      provides: "All references use WP_Clean_Up::OPTION_KEY constant"
      contains: "WP_Clean_Up::OPTION_KEY"
    - path: "uninstall.php"
      provides: "delete_option uses OPTION_KEY constant"
      contains: "WP_Clean_Up::OPTION_KEY"
  key_links:
    - from: "admin-clean-up.php::get_options()"
      to: "parse_args_recursive()"
      via: "replaces wp_parse_args() call"
      pattern: "self::parse_args_recursive"
    - from: "admin-clean-up.php::wp_clean_up_activate()"
      to: "WP_Clean_Up::get_options() defaults structure"
      via: "activation hook uses same complete defaults as get_options()"
      pattern: "add_option.*self::OPTION_KEY"
    - from: "includes/class-admin-page.php"
      to: "WP_Clean_Up::OPTION_KEY"
      via: "register_setting and form field names reference constant"
      pattern: "WP_Clean_Up::OPTION_KEY"
---

<objective>
Fix deep option merging, replace hardcoded option key string with class constant, and sync activation hook defaults with the full options structure.

Purpose: These three fixes eliminate the root cause of missing defaults on nested arrays, prevent option key typos across 46+ occurrences, and ensure fresh installations start with a complete options structure.

Output: Updated admin-clean-up.php (constant + recursive merge + complete activation defaults), updated class-admin-page.php (all string occurrences replaced with constant), updated uninstall.php (constant reference).
</objective>

<execution_context>
@/Users/lucas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-code-quality-foundation/01-RESEARCH.md

@admin-clean-up.php
@includes/class-admin-page.php
@uninstall.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OPTION_KEY constant, parse_args_recursive(), and fix get_options()</name>
  <files>admin-clean-up.php</files>
  <action>
In the WP_Clean_Up class (admin-clean-up.php):

1. Add a class constant after the $instance property:
   ```php
   /**
    * Option key for storing plugin settings.
    */
   const OPTION_KEY = 'wp_clean_up_options';
   ```

2. Add a private static method `parse_args_recursive()` before or after `get_options()`:
   ```php
   /**
    * Recursive version of wp_parse_args() for nested arrays.
    *
    * @param array $args     User-defined arguments.
    * @param array $defaults Default parameters.
    * @return array Merged array.
    */
   private static function parse_args_recursive( $args, $defaults ) {
       $args     = (array) $args;
       $defaults = (array) $defaults;
       $result   = $defaults;

       foreach ( $args as $key => $value ) {
           if ( is_array( $value ) && isset( $result[ $key ] ) && is_array( $result[ $key ] ) ) {
               $result[ $key ] = self::parse_args_recursive( $value, $result[ $key ] );
           } else {
               $result[ $key ] = $value;
           }
       }

       return $result;
   }
   ```

3. In `get_options()`, replace:
   - `get_option( 'wp_clean_up_options', [] )` with `get_option( self::OPTION_KEY, [] )`
   - `wp_parse_args( $options, $defaults )` with `self::parse_args_recursive( $options, $defaults )`

4. Update the activation hook function `wp_clean_up_activate()`:
   - Replace both `get_option( 'wp_clean_up_options' )` and `add_option( 'wp_clean_up_options', ... )` with `WP_Clean_Up::OPTION_KEY`
   - Replace the partial defaults array (only adminbar + comments) with the COMPLETE defaults matching the structure in get_options() -- all 9 tabs with all 45 keys. Copy the exact structure from get_options().

IMPORTANT: The activation hook must set the SAME default values as get_options() defines. All boolean defaults are `false`, string defaults are `''` for text fields, `'all'` for clean_filenames_types, `'default'` for core_updates, and `'non_admin'` for all *_for fields.
  </action>
  <verify>
Run: `grep -n "wp_clean_up_options" admin-clean-up.php`
Expected: Only the constant definition line should contain the literal string.

Run: `grep -c "self::OPTION_KEY\|WP_Clean_Up::OPTION_KEY" admin-clean-up.php`
Expected: At least 3 occurrences (get_options get_option, activate get_option, activate add_option).

Run: `grep -c "parse_args_recursive" admin-clean-up.php`
Expected: 2 (method definition + call in get_options).

Run: `php -l admin-clean-up.php`
Expected: No syntax errors.
  </verify>
  <done>
- OPTION_KEY constant defined with value 'wp_clean_up_options'
- parse_args_recursive() private static method exists
- get_options() uses parse_args_recursive() instead of wp_parse_args()
- get_options() uses self::OPTION_KEY instead of string literal
- Activation hook uses WP_Clean_Up::OPTION_KEY
- Activation hook sets complete defaults (all 9 tabs, 45 keys)
- No syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace all hardcoded option key strings in class-admin-page.php and uninstall.php</name>
  <files>includes/class-admin-page.php, uninstall.php</files>
  <action>
**In class-admin-page.php:**

1. In `register_settings()` (line 45): Replace `'wp_clean_up_options'` in register_setting() with `WP_Clean_Up::OPTION_KEY`. Note: The settings group name `'wp_clean_up_options_group'` is NOT the option key -- leave it as a string.

2. In `sanitize_options()` (line 75): Replace `get_option( 'wp_clean_up_options', [] )` with `get_option( WP_Clean_Up::OPTION_KEY, [] )`.

3. In `render_settings_page()` (line 329): The hidden input field `name="wp_clean_up_options[_current_tab]"` uses the option key as the HTML form name. Replace with:
   ```php
   <input type="hidden" name="<?php echo esc_attr( WP_Clean_Up::OPTION_KEY ); ?>[_current_tab]" value="<?php echo esc_attr( $current_tab ); ?>">
   ```

4. **All form field name attributes** throughout the render methods (39+ occurrences): Every `name="wp_clean_up_options[...]"` must become `name="<?php echo esc_attr( WP_Clean_Up::OPTION_KEY ); ?>[...]"`. This applies to ALL render_*_tab() methods:
   - render_adminbar_tab: 5 checkbox inputs
   - render_comments_tab: 1 checkbox input
   - render_dashboard_tab: 7 checkbox inputs
   - render_menus_tab: 8 checkbox inputs + 8 select fields (uses dynamic key construction via esc_attr($key) -- update the prefix part only)
   - render_footer_tab: 2 checkbox inputs + 2 text inputs
   - render_notices_tab: 4 checkbox inputs
   - render_media_tab: 1 checkbox + 2 radio inputs
   - render_plugins_tab: 1 checkbox input (uses dynamic $plugin['option'])
   - render_updates_tab: 5 radio inputs + 4 checkbox inputs

   Pattern for static names:
   ```php
   // Before:
   name="wp_clean_up_options[adminbar][remove_wp_logo]"
   // After:
   name="<?php echo esc_attr( WP_Clean_Up::OPTION_KEY ); ?>[adminbar][remove_wp_logo]"
   ```

   Pattern for dynamic names (menus tab):
   ```php
   // Before:
   name="wp_clean_up_options[menus][remove_<?php echo esc_attr( $key ); ?>]"
   // After:
   name="<?php echo esc_attr( WP_Clean_Up::OPTION_KEY ); ?>[menus][remove_<?php echo esc_attr( $key ); ?>]"
   ```

**In uninstall.php:**

5. The file cannot use `WP_Clean_Up::OPTION_KEY` directly because the plugin class is not loaded during uninstall. Instead:
   - Add `require_once __DIR__ . '/admin-clean-up.php';` is NOT appropriate for uninstall (it would run the plugin).
   - Instead, define the constant inline OR reference the class constant. Since uninstall.php runs with WordPress loaded, we can require just enough:
   ```php
   // Load only the constant definition
   if ( class_exists( 'WP_Clean_Up' ) ) {
       delete_option( WP_Clean_Up::OPTION_KEY );
   } else {
       delete_option( 'wp_clean_up_options' );
   }
   ```
   Actually, the simplest safe approach: Since uninstall is the ONE place where the plugin is being deleted, keep the string literal BUT add a comment referencing the constant. This is the WordPress-standard pattern for uninstall.php (plugin code is deactivated).

   DECISION: Keep uninstall.php as `delete_option( 'wp_clean_up_options' );` with a comment `// Matches WP_Clean_Up::OPTION_KEY`. The roadmap success criterion says "except the constant definition" -- uninstall.php is a legitimate exception since the class isn't loaded. However, to truly meet the criterion, we can define a local constant:
   ```php
   // Option key must match WP_Clean_Up::OPTION_KEY
   delete_option( 'wp_clean_up_options' );
   ```

   WAIT - re-reading the success criterion: "The string 'wp_clean_up_options' appears nowhere in the codebase except the constant definition". This means uninstall.php must NOT have the raw string. Solution: Include the main plugin file's constant. Since uninstall runs in WordPress context, we can safely require just enough:
   ```php
   // Require plugin file to access the OPTION_KEY constant
   require_once __DIR__ . '/admin-clean-up.php';
   delete_option( WP_Clean_Up::OPTION_KEY );
   ```
   BUT this would initialize the entire plugin (singleton, all modules). NOT safe.

   Better solution: Extract the constant to a minimal file, or just define it directly:
   ```php
   delete_option( 'wp_clean_up_options' );
   ```
   Replace with defining it locally in uninstall.php to satisfy the criterion without loading the plugin. The constant is defined in the class, so in uninstall:
   ```php
   // Must match the OPTION_KEY constant in WP_Clean_Up class
   $option_key = 'wp_clean_up_options';
   delete_option( $option_key );
   ```
   This still has the literal string. The CLEANEST approach that satisfies "string appears nowhere except constant definition":

   Load ONLY the class definition without triggering singleton:
   Since the plugin uses `add_action( 'plugins_loaded', 'wp_clean_up_init' )`, the class definition exists but get_instance() won't be called during uninstall. We CAN safely `require_once` the file because:
   - The `define()` calls at top will run (harmless -- constants already defined or not)
   - The class is defined but not instantiated
   - `wp_clean_up_init()` is added to `plugins_loaded` which won't fire during uninstall
   - `register_activation_hook()` won't fire either

   Final approach for uninstall.php:
   ```php
   <?php
   /**
    * Uninstall WP Clean Up
    *
    * Removes all plugin data when the plugin is deleted.
    *
    * @package WP_Clean_Up
    */

   // If uninstall not called from WordPress, exit
   if ( ! defined( 'WP_UNINSTALL_PLUGIN' ) ) {
       exit;
   }

   // Load plugin to access OPTION_KEY constant
   require_once __DIR__ . '/admin-clean-up.php';

   // Delete plugin options
   delete_option( WP_Clean_Up::OPTION_KEY );
   ```

   This is safe because `plugins_loaded` action doesn't fire during uninstall, so `wp_clean_up_init()` never runs, no singleton is created, no modules initialize.
  </action>
  <verify>
Run: `grep -rn "wp_clean_up_options" --include="*.php" .`
Expected: ONLY the constant definition line in admin-clean-up.php (the `const OPTION_KEY = 'wp_clean_up_options';` line). Zero occurrences in class-admin-page.php and uninstall.php. Note: `wp_clean_up_options_group` (settings group name) is different and is allowed to remain.

Run: `grep -c "WP_Clean_Up::OPTION_KEY" includes/class-admin-page.php`
Expected: 40+ occurrences (2 in register/sanitize + 39+ in form fields + 1 hidden input).

Run: `php -l includes/class-admin-page.php && php -l uninstall.php`
Expected: No syntax errors.
  </verify>
  <done>
- class-admin-page.php: register_setting() uses WP_Clean_Up::OPTION_KEY
- class-admin-page.php: sanitize_options() uses WP_Clean_Up::OPTION_KEY
- class-admin-page.php: All form field name attributes use the constant via PHP echo
- class-admin-page.php: Hidden _current_tab input uses constant
- uninstall.php: Uses WP_Clean_Up::OPTION_KEY via require_once
- No raw 'wp_clean_up_options' string appears anywhere except the constant definition (wp_clean_up_options_group is a different string and is allowed)
- No syntax errors in any modified file
  </done>
</task>

</tasks>

<verification>
1. `grep -rn "'wp_clean_up_options'" --include="*.php" .` -- Only ONE match: the constant definition
2. `grep -rn "wp_clean_up_options" --include="*.php" . | grep -v "OPTION_KEY\|options_group"` -- Only the constant definition line
3. `php -l admin-clean-up.php && php -l includes/class-admin-page.php && php -l uninstall.php` -- All pass
4. `grep -c "parse_args_recursive" admin-clean-up.php` -- Returns 2 (definition + usage)
5. Activation hook defaults array contains all 9 top-level keys (adminbar, comments, dashboard, menus, footer, notices, media, plugins, updates)
</verification>

<success_criteria>
- Deep merge: get_options() uses parse_args_recursive() ensuring nested defaults always apply
- Constant: WP_Clean_Up::OPTION_KEY defined, used everywhere, no stray string literals
- Activation sync: wp_clean_up_activate() sets complete defaults matching get_options() structure (45 keys in 9 tabs)
- All PHP files pass syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/01-code-quality-foundation/01-01-SUMMARY.md`
</output>
